#!/bin/bash
#
# Smart Proxy Router Setup
# Routes traffic based on domain:
#   - YouTube domains → ByeDPI (DPI bypass) → Direct
#   - .ru/.su/.рф domains → Direct
#   - Everything else → VLESS proxy
#
# Usage: sudo bash setup-proxy.sh
#
set -e

# ============ CONFIGURATION ============
PROXY_PORT=1081                    # SOCKS5 proxy port for clients
HTTP_PROXY_PORT=1082               # HTTP proxy port for clients (e.g., Claude Code)
BYEDPI_PORT=1080                   # Internal ByeDPI port
BYEDPI_ARGS="--tlsrec 2+s"         # ByeDPI arguments for DPI bypass

# VLESS server config - will be set interactively or from config.env
VLESS_ADDRESS=""
VLESS_PORT=""
VLESS_UUID=""
VLESS_PATH=""
# =======================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${GREEN}[+]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[x]${NC} $1"; exit 1; }
info() { echo -e "${BLUE}[i]${NC} $1"; }

# ============ VLESS CONFIGURATION ============
configure_vless() {
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

    # Try to load from config.env if it exists
    if [[ -f "${SCRIPT_DIR}/config.env" ]]; then
        log "Loading configuration from config.env..."
        source "${SCRIPT_DIR}/config.env"
    fi

    echo ""
    echo -e "${GREEN}════════════════════════════════════════════${NC}"
    echo -e "${GREEN}       VLESS Configuration Setup${NC}"
    echo -e "${GREEN}════════════════════════════════════════════${NC}"
    echo ""

    # Check if all values are already set (from config.env)
    if [[ -n "$VLESS_ADDRESS" && -n "$VLESS_PORT" && -n "$VLESS_UUID" && -n "$VLESS_PATH" ]]; then
        info "Found existing configuration:"
        echo "  Address: $VLESS_ADDRESS"
        echo "  Port:    $VLESS_PORT"
        echo "  UUID:    ${VLESS_UUID:0:8}..."
        echo "  Path:    $VLESS_PATH"
        echo ""
        read -p "Use this configuration? [Y/n]: " use_existing
        if [[ "${use_existing,,}" != "n" ]]; then
            return 0
        fi
    fi

    info "Please enter your VLESS server details."
    info "You can get these from your VLESS provider or server setup."
    echo ""

    # VLESS Address
    while [[ -z "$VLESS_ADDRESS" ]]; do
        read -p "VLESS Server Address (e.g., your-server.com): " VLESS_ADDRESS
        if [[ -z "$VLESS_ADDRESS" ]]; then
            warn "Address cannot be empty. Please try again."
        fi
    done

    # VLESS Port
    while [[ -z "$VLESS_PORT" || ! "$VLESS_PORT" =~ ^[0-9]+$ ]]; do
        read -p "VLESS Server Port [443]: " VLESS_PORT
        VLESS_PORT="${VLESS_PORT:-443}"
        if ! [[ "$VLESS_PORT" =~ ^[0-9]+$ ]]; then
            warn "Port must be a number. Please try again."
            VLESS_PORT=""
        fi
    done

    # VLESS UUID
    while [[ -z "$VLESS_UUID" ]]; do
        read -p "VLESS UUID: " VLESS_UUID
        if [[ -z "$VLESS_UUID" ]]; then
            warn "UUID cannot be empty. Please try again."
        elif ! [[ "$VLESS_UUID" =~ ^[0-9a-fA-F-]+$ ]]; then
            warn "UUID format appears invalid, but continuing anyway..."
        fi
    done

    # VLESS Path
    while [[ -z "$VLESS_PATH" ]]; do
        read -p "VLESS WebSocket Path (e.g., /ws): " VLESS_PATH
        if [[ -z "$VLESS_PATH" ]]; then
            warn "Path cannot be empty. Please try again."
        fi
        # Ensure path starts with /
        if [[ "${VLESS_PATH:0:1}" != "/" ]]; then
            VLESS_PATH="/${VLESS_PATH}"
        fi
    done

    echo ""
    log "Configuration summary:"
    echo "  Address: $VLESS_ADDRESS"
    echo "  Port:    $VLESS_PORT"
    echo "  UUID:    ${VLESS_UUID:0:8}..."
    echo "  Path:    $VLESS_PATH"
    echo ""

    read -p "Proceed with this configuration? [Y/n]: " confirm
    if [[ "${confirm,,}" == "n" ]]; then
        error "Configuration cancelled by user."
    fi

    # Optionally save to config.env
    read -p "Save configuration to config.env for future use? [y/N]: " save_config
    if [[ "${save_config,,}" == "y" ]]; then
        cat > "${SCRIPT_DIR}/config.env" << EOF
# VLESS Configuration
# Generated by setup-proxy.sh

VLESS_ADDRESS="$VLESS_ADDRESS"
VLESS_PORT=$VLESS_PORT
VLESS_UUID="$VLESS_UUID"
VLESS_PATH="$VLESS_PATH"
EOF
        log "Configuration saved to config.env"
        warn "Note: config.env contains sensitive data and is excluded from git"
    fi
}

# Check root
[[ $EUID -ne 0 ]] && error "This script must be run as root (sudo)"

# Configure VLESS interactively
configure_vless

# Detect architecture
ARCH=$(uname -m)
case $ARCH in
    x86_64) XRAY_ARCH="64" ;;
    aarch64|arm64) XRAY_ARCH="arm64-v8a" ;;
    armv7l) XRAY_ARCH="arm32-v7a" ;;
    *) error "Unsupported architecture: $ARCH" ;;
esac

log "Detected architecture: $ARCH"

# Install dependencies
log "Installing dependencies..."
if command -v pacman &>/dev/null; then
    pacman -Sy --noconfirm --needed curl unzip git base-devel
elif command -v apt-get &>/dev/null; then
    apt-get update && apt-get install -y curl unzip git build-essential
elif command -v dnf &>/dev/null; then
    dnf install -y curl unzip git gcc make
elif command -v apk &>/dev/null; then
    apk add curl unzip git build-base
else
    warn "Unknown package manager, assuming dependencies are installed"
fi

# Create directories
log "Creating directories..."
mkdir -p /opt/proxy/{xray,byedpi}

# Install xray-core
log "Installing xray-core..."
cd /opt/proxy
XRAY_VERSION=$(curl -s https://api.github.com/repos/XTLS/Xray-core/releases/latest | grep tag_name | cut -d'"' -f4)
log "Latest xray version: $XRAY_VERSION"
curl -L -o xray.zip "https://github.com/XTLS/Xray-core/releases/download/${XRAY_VERSION}/Xray-linux-${XRAY_ARCH}.zip"
unzip -o xray.zip -d xray/
chmod +x xray/xray
rm -f xray.zip
log "Xray installed: $(xray/xray version | head -1)"

# Install ByeDPI
log "Installing ByeDPI..."
cd /opt/proxy/byedpi
if [[ -d src ]]; then
    cd src && git pull
else
    git clone --depth 1 https://github.com/hufrea/byedpi.git src
    cd src
fi
make clean 2>/dev/null || true
make
cp ciadpi /opt/proxy/byedpi/
log "ByeDPI installed"

# Disable IPv6 (required for ByeDPI to work reliably)
log "Disabling IPv6 for outgoing connections..."
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1
cat > /etc/sysctl.d/99-disable-ipv6.conf << EOF
net.ipv6.conf.all.disable_ipv6=1
net.ipv6.conf.default.disable_ipv6=1
EOF

# Create xray config
log "Creating xray configuration..."
cat > /opt/proxy/xray/config.json << XRAYEOF
{
  "log": {
    "loglevel": "warning"
  },
  "dns": {
    "servers": ["8.8.8.8", "1.1.1.1"],
    "queryStrategy": "UseIPv4"
  },
  "inbounds": [
    {
      "tag": "socks-in",
      "port": ${PROXY_PORT},
      "listen": "0.0.0.0",
      "protocol": "socks",
      "settings": {
        "auth": "noauth",
        "udp": true
      },
      "sniffing": {
        "enabled": true,
        "destOverride": ["http", "tls"],
        "routeOnly": false
      }
    }
  ],
  "outbounds": [
    {
      "tag": "vless-out",
      "protocol": "vless",
      "settings": {
        "vnext": [
          {
            "address": "${VLESS_ADDRESS}",
            "port": ${VLESS_PORT},
            "users": [
              {
                "id": "${VLESS_UUID}",
                "encryption": "none"
              }
            ]
          }
        ]
      },
      "streamSettings": {
        "network": "ws",
        "security": "tls",
        "tlsSettings": {
          "serverName": "${VLESS_ADDRESS}",
          "fingerprint": "chrome"
        },
        "wsSettings": {
          "path": "${VLESS_PATH}"
        }
      }
    },
    {
      "tag": "byedpi-out",
      "protocol": "socks",
      "settings": {
        "servers": [
          {
            "address": "127.0.0.1",
            "port": ${BYEDPI_PORT}
          }
        ]
      }
    },
    {
      "tag": "direct",
      "protocol": "freedom",
      "settings": {
        "domainStrategy": "UseIPv4"
      }
    }
  ],
  "routing": {
    "domainStrategy": "IPIfNonMatch",
    "rules": [
      {
        "type": "field",
        "domain": [
          "domain:youtube.com",
          "domain:youtu.be",
          "domain:ytimg.com",
          "domain:yt3.ggpht.com",
          "domain:googlevideo.com",
          "domain:youtube-nocookie.com"
        ],
        "outboundTag": "byedpi-out"
      },
      {
        "type": "field",
        "domain": [
          "regexp:\\\\.ru$",
          "regexp:\\\\.su$",
          "regexp:\\\\.xn--p1ai$"
        ],
        "outboundTag": "direct"
      },
      {
        "type": "field",
        "network": "tcp,udp",
        "outboundTag": "vless-out"
      }
    ]
  }
}
XRAYEOF

# Create systemd services
log "Creating systemd services..."

cat > /etc/systemd/system/byedpi.service << EOF
[Unit]
Description=ByeDPI - DPI bypass proxy
After=network.target

[Service]
Type=simple
ExecStart=/opt/proxy/byedpi/ciadpi -i 127.0.0.1 -p ${BYEDPI_PORT} ${BYEDPI_ARGS}
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

cat > /etc/systemd/system/xray-router.service << EOF
[Unit]
Description=Xray Routing Proxy
After=network.target byedpi.service
Wants=byedpi.service

[Service]
Type=simple
ExecStart=/opt/proxy/xray/xray run -config /opt/proxy/xray/config.json
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# Open firewall ports
if systemctl is-active --quiet firewalld; then
    log "Opening ports ${PROXY_PORT} and ${HTTP_PROXY_PORT} in firewalld..."
    firewall-cmd --add-port=${PROXY_PORT}/tcp --permanent
    firewall-cmd --add-port=${PROXY_PORT}/udp --permanent
    firewall-cmd --add-port=${HTTP_PROXY_PORT}/tcp --permanent
    firewall-cmd --reload
elif command -v ufw &>/dev/null && ufw status | grep -q "active"; then
    log "Opening ports ${PROXY_PORT} and ${HTTP_PROXY_PORT} in ufw..."
    ufw allow ${PROXY_PORT}/tcp
    ufw allow ${PROXY_PORT}/udp
    ufw allow ${HTTP_PROXY_PORT}/tcp
fi

# Enable and start services
log "Starting services..."
systemctl daemon-reload
systemctl enable byedpi xray-router
systemctl restart byedpi
sleep 2
systemctl restart xray-router
sleep 2

# Verify services
log "Verifying services..."
if systemctl is-active --quiet byedpi && systemctl is-active --quiet xray-router; then
    log "All services are running"
else
    error "Services failed to start. Check: journalctl -u xray-router -u byedpi"
fi

# Test routing
log "Testing routing..."
echo ""

test_route() {
    local name=$1
    local url=$2
    local expected=$3
    local result=$(curl -s -x socks5h://127.0.0.1:${PROXY_PORT} --connect-timeout 10 -o /dev/null -w "%{http_code}" "$url" 2>/dev/null)
    if [[ "$result" =~ ^[23] ]]; then
        echo -e "  ${GREEN}✓${NC} $name: $result"
    else
        echo -e "  ${RED}✗${NC} $name: $result (expected 2xx/3xx)"
    fi
}

test_route "YouTube (ByeDPI)" "https://www.youtube.com"
test_route "Yandex.ru (Direct)" "https://ya.ru"
test_route "Google (VLESS)" "https://www.google.com"

echo ""
echo -e "${GREEN}════════════════════════════════════════════${NC}"
echo -e "${GREEN}       Setup Complete!${NC}"
echo -e "${GREEN}════════════════════════════════════════════${NC}"
echo ""
echo "  SOCKS5 Proxy: $(hostname -I | awk '{print $1}'):${PROXY_PORT}"
echo "  Authentication: None"
echo ""
echo "  Routing:"
echo "    YouTube     → ByeDPI (DPI bypass)"
echo "    .ru/.su/.рф → Direct"
echo "    Other       → VLESS (${VLESS_ADDRESS})"
echo ""
echo "  Commands:"
echo "    Status:  systemctl status byedpi xray-router"
echo "    Logs:    journalctl -u xray-router -f"
echo "    Restart: systemctl restart byedpi xray-router"
echo ""
